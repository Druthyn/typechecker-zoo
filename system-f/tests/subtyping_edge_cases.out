# Subtyping and Higher-Rank Polymorphism Edge Cases

# 1. Basic subtyping - monotypes
42 : Int
true : Bool
\x : Int -> x : Int -> Int
\x : Bool -> x : Bool -> Bool

# 2. Polymorphic identity should work with any type
(forall a. \x : a -> x) [Int] 42 : Int
(forall a. \x : a -> x) [Bool] true : Bool
(forall a. \x : a -> x) [(Int -> Int)] (\y : Int -> y) : Int -> Int

# 3. Rank-2 polymorphism - functions accepting polymorphic functions
\k : (forall a. a -> a) -> k [Int] 42 : ∀a. a -> a -> Int

# 4. Subtyping with existentials (System-F with existentials)
\f : (Int -> Int) -> f : (Int -> Int) -> Int -> Int
\g : (forall a. a -> a) -> g : ∀a. a -> a -> ^α0

# 5. Complex nested applications that should work
(\p : (forall x. x -> x) -> p) (forall y. \z : y -> z) : ^α0

# 6. Church encoding applications
(forall a. \t : a -> \f : a -> t) [Int] 42 0 : Int

# 7. Nested type abstractions applied step by step
forall a. forall b. \x : a -> x : ∀a. ∀b. a -> a
(forall a. forall b. \x : a -> x) [Int] : ∀b. Int -> Int
((forall a. forall b. \x : a -> x) [Int]) [Bool] : Int -> Int

# 8. Testing instantiation with complex arrow types
(forall a. \x : a -> x) [(Bool -> Bool -> Bool)] : ((Bool -> Bool) -> Bool) -> (Bool -> Bool) -> Bool

# 9. Higher-order polymorphic function composition
forall a. forall b. forall c. \f : (b -> c) -> \g : (a -> b) -> \x : a -> f (g x) : ∀a. ∀b. ∀c. (b -> c) -> (a -> b) -> a -> c

# 10. Apply polymorphic function multiple times
\h : (forall a. a -> a) -> \x : Int -> \y : Bool -> h [Int] (h [Bool] y) : ERROR: No matching rule for subtyping Bool <: Int

# Edge cases that should produce type errors

# 11. Type mismatch - applying Int function to Bool
(\x : Int -> x) true : ERROR: No matching rule for subtyping Bool <: Int

# 12. Trying to instantiate non-polymorphic function
(\x : Int -> x) [Bool] : ERROR: Expected forall type in type application, got Int -> ^α0

# 13. Wrong number of arguments
(forall a. \x : a -> x) 42 : ERROR: Expected function type in application, got ∀a. a -> a

# 14. Complex type mismatch in nested application
\f : (Int -> Int) -> \g : (Bool -> Bool) -> f g : ERROR: No matching rule for subtyping Bool -> Bool <: Int

# 15. Existential variable escape (should be caught)
\x : ^a -> x : ^α0 -> ^α0

# 16. Invalid type variable reference
\x : b -> x : b -> b

# 17. Applying concrete function as if polymorphic
(\id : (Int -> Int) -> id [Bool]) (\x : Int -> x) : ERROR: Expected forall type in type application, got Int -> Int

# 18. Complex rank-2 error case
\app : ((forall a. a -> a) -> Int) -> app (\x : Bool -> x) : (∀a. a -> a -> Int) -> Int

# 19. Type annotation mismatch
(\x : Int -> x : Bool -> Bool) : Bool -> Bool

# 20. Nested error propagation
(\bad : (forall a. a -> Int) -> bad [Bool] true) (\wrong : Bool -> wrong) : ERROR: No matching rule for subtyping a <: Int
